/*!
  * Bootstrap v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
import * as Popper from '@popperjs/core'; const MAX_UID = 1e6; const MILLISECONDS_MULTIPLIER = 1e3; const TRANSITION_END = 'transitionend'; const toType = e => e == null ? '' + e : {}.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase(); const getUID = e => { do { e += Math.floor(1e6 * Math.random()); } while (document.getElementById(e)); return e; }; const getSelector = e => { let t = e.getAttribute('data-bs-target'); if (!t || t === '#') { let i = e.getAttribute('href'); if (!i || !i.includes('#') && !i.startsWith('.')) return null; i.includes('#') && !i.startsWith('#') && (i = '#' + i.split('#')[1]), t = i && i !== '#' ? i.trim() : null; } return t; }; const getSelectorFromElement = e => { const t = getSelector(e); return t && document.querySelector(t) ? t : null; }; const getElementFromSelector = e => { const t = getSelector(e); return t ? document.querySelector(t) : null; }; const getTransitionDurationFromElement = e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e); const n = Number.parseFloat(t); const s = Number.parseFloat(i); return n || s ? (t = t.split(',')[0], i = i.split(',')[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0; }; const triggerTransitionEnd = e => { e.dispatchEvent(new Event(TRANSITION_END)); }; const isElement = e => !(!e || typeof e !== 'object') && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType); const getElement = e => isElement(e) ? e.jquery ? e[0] : e : typeof e === 'string' && e.length > 0 ? document.querySelector(e) : null; const typeCheckConfig = (e, t, i) => { Object.keys(i).forEach(n => { const s = i[n]; const o = t[n]; const r = o && isElement(o) ? 'element' : (a = o) == null ? '' + a : {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase(); let a; if (!new RegExp(s).test(r)) throw new TypeError(`${e.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`); }); }; const isVisible = e => !(!isElement(e) || e.getClientRects().length === 0) && getComputedStyle(e).getPropertyValue('visibility') === 'visible'; const isDisabled = e => !e || e.nodeType !== Node.ELEMENT_NODE || !!e.classList.contains('disabled') || (void 0 !== e.disabled ? e.disabled : e.hasAttribute('disabled') && e.getAttribute('disabled') !== 'false'); const findShadowRoot = e => { if (!document.documentElement.attachShadow) return null; if (typeof e.getRootNode === 'function') { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null; } return e instanceof ShadowRoot ? e : e.parentNode ? findShadowRoot(e.parentNode) : null; }; const noop = () => {}; const reflow = e => { e.offsetHeight; }; const getjQuery = () => { const { jQuery: e } = window; return e && !document.body.hasAttribute('data-bs-no-jquery') ? e : null; }; const DOMContentLoadedCallbacks = []; const onDOMContentLoaded = e => { document.readyState === 'loading' ? (DOMContentLoadedCallbacks.length || document.addEventListener('DOMContentLoaded', () => { DOMContentLoadedCallbacks.forEach(e => e()); }), DOMContentLoadedCallbacks.push(e)) : e(); }; const isRTL = () => document.documentElement.dir === 'rtl'; const defineJQueryPlugin = e => { let t; t = () => { const t = getjQuery(); if (t) { const i = e.NAME; const n = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = n, e.jQueryInterface); } }, document.readyState === 'loading' ? (DOMContentLoadedCallbacks.length || document.addEventListener('DOMContentLoaded', () => { DOMContentLoadedCallbacks.forEach(e => e()); }), DOMContentLoadedCallbacks.push(t)) : t(); }; const execute = e => { typeof e === 'function' && e(); }; const executeAfterTransition = (e, t, i = !0) => { if (!i) return void execute(e); const n = getTransitionDurationFromElement(t) + 5; let s = !1; const o = ({ target: i }) => { i === t && (s = !0, t.removeEventListener(TRANSITION_END, o), execute(e)); }; t.addEventListener(TRANSITION_END, o), setTimeout(() => { s || triggerTransitionEnd(t); }, n); }; const getNextActiveElement = (e, t, i, n) => { let s = e.indexOf(t); if (s === -1) return e[!i && n ? e.length - 1 : 0]; const o = e.length; return s += i ? 1 : -1, n && (s = (s + o) % o), e[Math.max(0, Math.min(s, o - 1))]; }; const namespaceRegex = /[^.]*(?=\..*)\.|.*/; const stripNameRegex = /\..*/; const stripUidRegex = /::\d+$/; const eventRegistry = {}; let uidEvent = 1; const customEvents = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const customEventsRegex = /^(mouseenter|mouseleave)/i; const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function getUidEvent (e, t) { return t && `${t}::${uidEvent++}` || e.uidEvent || uidEvent++; } function getEvent (e) { const t = getUidEvent(e); return e.uidEvent = t, eventRegistry[t] = eventRegistry[t] || {}, eventRegistry[t]; } function bootstrapHandler (e, t) { return function i (n) { return n.delegateTarget = e, i.oneOff && EventHandler.off(e, n.type, t), t.apply(e, [n]); }; } function bootstrapDelegationHandler (e, t, i) { return function n (s) { const o = e.querySelectorAll(t); for (let { target: r } = s; r && r !== this; r = r.parentNode) for (let a = o.length; a--;) if (o[a] === r) return s.delegateTarget = r, n.oneOff && EventHandler.off(e, s.type, t, i), i.apply(r, [s]); return null; }; } function findHandler (e, t, i = null) { const n = Object.keys(e); for (let s = 0, o = n.length; s < o; s++) { const o = e[n[s]]; if (o.originalHandler === t && o.delegationSelector === i) return o; } return null; } function normalizeParams (e, t, i) { const n = typeof t === 'string'; const s = n ? i : t; let o = getTypeEvent(e); return nativeEvents.has(o) || (o = e), [n, s, o]; } function addHandler (e, t, i, n, s) { if (typeof t !== 'string' || !e) return; if (i || (i = n, n = null), customEventsRegex.test(t)) { const e = e => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t); }; n ? n = e(n) : i = e(i); } const [o, r, a] = normalizeParams(t, i, n); const l = getEvent(e); const c = l[a] || (l[a] = {}); const _ = findHandler(c, r, o ? i : null); if (_) return void (_.oneOff = _.oneOff && s); const h = getUidEvent(r, t.replace(namespaceRegex, '')); const E = o ? bootstrapDelegationHandler(e, i, n) : bootstrapHandler(e, i); E.delegationSelector = o ? i : null, E.originalHandler = r, E.oneOff = s, E.uidEvent = h, c[h] = E, e.addEventListener(a, E, o); } function removeHandler (e, t, i, n, s) { const o = findHandler(t[i], n, s); o && (e.removeEventListener(i, o, Boolean(s)), delete t[i][o.uidEvent]); } function removeNamespacedHandlers (e, t, i, n) { const s = t[i] || {}; Object.keys(s).forEach(o => { if (o.includes(n)) { const n = s[o]; removeHandler(e, t, i, n.originalHandler, n.delegationSelector); } }); } function getTypeEvent (e) { return e = e.replace(stripNameRegex, ''), customEvents[e] || e; } const EventHandler = { on (e, t, i, n) { addHandler(e, t, i, n, !1); }, one (e, t, i, n) { addHandler(e, t, i, n, !0); }, off (e, t, i, n) { if (typeof t !== 'string' || !e) return; const [s, o, r] = normalizeParams(t, i, n); const a = r !== t; const l = getEvent(e); const c = t.startsWith('.'); if (void 0 !== o) { if (!l || !l[r]) return; return void removeHandler(e, l, r, o, s ? i : null); }c && Object.keys(l).forEach(i => { removeNamespacedHandlers(e, l, i, t.slice(1)); }); const _ = l[r] || {}; Object.keys(_).forEach(i => { const n = i.replace(stripUidRegex, ''); if (!a || t.includes(n)) { const t = _[i]; removeHandler(e, l, r, t.originalHandler, t.delegationSelector); } }); }, trigger (e, t, i) { if (typeof t !== 'string' || !e) return null; const n = getjQuery(); const s = getTypeEvent(t); const o = t !== s; const r = nativeEvents.has(s); let a; let l = !0; let c = !0; let _ = !1; let h = null; return o && n && (a = n.Event(t, i), n(e).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), _ = a.isDefaultPrevented()), r ? (h = document.createEvent('HTMLEvents'), h.initEvent(s, l, !0)) : h = new CustomEvent(t, { bubbles: l, cancelable: !0 }), void 0 !== i && Object.keys(i).forEach(e => { Object.defineProperty(h, e, { get: () => i[e] }); }), _ && h.preventDefault(), c && e.dispatchEvent(h), h.defaultPrevented && void 0 !== a && a.preventDefault(), h; } }; const elementMap = new Map(); const Data = { set (e, t, i) { elementMap.has(e) || elementMap.set(e, new Map()); const n = elementMap.get(e); n.has(t) || n.size === 0 ? n.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`); }, get: (e, t) => elementMap.has(e) && elementMap.get(e).get(t) || null, remove (e, t) { if (!elementMap.has(e)) return; const i = elementMap.get(e); i.delete(t), i.size === 0 && elementMap.delete(e); } }; const VERSION = '5.1.0'; class BaseComponent {constructor (e) { (e = getElement(e)) && (this._element = e, Data.set(this._element, this.constructor.DATA_KEY, this)); }dispose () { Data.remove(this._element, this.constructor.DATA_KEY), EventHandler.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(e => { this[e] = null; }); }_queueCallback (e, t, i = !0) { executeAfterTransition(e, t, i); } static getInstance (e) { return Data.get(getElement(e), this.DATA_KEY); } static getOrCreateInstance (e, t = {}) { return this.getInstance(e) || new this(e, typeof t === 'object' ? t : null); } static get VERSION () { return '5.1.0'; } static get NAME () { throw new Error('You have to implement the static method "NAME", for each component!'); } static get DATA_KEY () { return 'bs.' + this.NAME; } static get EVENT_KEY () { return '.' + this.DATA_KEY; }} const enableDismissTrigger = (e, t = 'hide') => { const i = 'click.dismiss' + e.EVENT_KEY; const n = e.NAME; EventHandler.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) { if (['A', 'AREA'].includes(this.tagName) && i.preventDefault(), isDisabled(this)) return; const s = getElementFromSelector(this) || this.closest('.' + n); e.getOrCreateInstance(s)[t](); }); }; const NAME$d = 'alert'; const DATA_KEY$c = 'bs.alert'; const EVENT_KEY$c = '.bs.alert'; const EVENT_CLOSE = 'close.bs.alert'; const EVENT_CLOSED = 'closed.bs.alert'; const CLASS_NAME_FADE$5 = 'fade'; const CLASS_NAME_SHOW$8 = 'show'; class Alert extends BaseComponent {static get NAME () { return NAME$d; }close () { if (EventHandler.trigger(this._element, EVENT_CLOSE).defaultPrevented) return; this._element.classList.remove('show'); const e = this._element.classList.contains('fade'); this._queueCallback(() => this._destroyElement(), this._element, e); }_destroyElement () { this._element.remove(), EventHandler.trigger(this._element, EVENT_CLOSED), this.dispose(); } static jQueryInterface (e) { return this.each(function () { const t = Alert.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this); } }); }}enableDismissTrigger(Alert, 'close'), defineJQueryPlugin(Alert); const NAME$c = 'button'; const DATA_KEY$b = 'bs.button'; const EVENT_KEY$b = '.bs.button'; const DATA_API_KEY$7 = '.data-api'; const CLASS_NAME_ACTIVE$3 = 'active'; const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]'; const EVENT_CLICK_DATA_API$6 = 'click.bs.button.data-api'; class Button extends BaseComponent {static get NAME () { return NAME$c; }toggle () { this._element.setAttribute('aria-pressed', this._element.classList.toggle('active')); } static jQueryInterface (e) { return this.each(function () { const t = Button.getOrCreateInstance(this); e === 'toggle' && t[e](); }); }} function normalizeData (e) { return e === 'true' || e !== 'false' && (e === Number(e).toString() ? Number(e) : e === '' || e === 'null' ? null : e); } function normalizeDataKey (e) { return e.replace(/[A-Z]/g, e => '-' + e.toLowerCase()); }EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, e => { e.preventDefault(); const t = e.target.closest(SELECTOR_DATA_TOGGLE$5); Button.getOrCreateInstance(t).toggle(); }), defineJQueryPlugin(Button); const Manipulator = { setDataAttribute (e, t, i) { e.setAttribute('data-bs-' + normalizeDataKey(t), i); }, removeDataAttribute (e, t) { e.removeAttribute('data-bs-' + normalizeDataKey(t)); }, getDataAttributes (e) { if (!e) return {}; const t = {}; return Object.keys(e.dataset).filter(e => e.startsWith('bs')).forEach(i => { let n = i.replace(/^bs/, ''); n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = normalizeData(e.dataset[i]); }), t; }, getDataAttribute: (e, t) => normalizeData(e.getAttribute('data-bs-' + normalizeDataKey(t))), offset (e) { const t = e.getBoundingClientRect(); return { top: t.top + window.pageYOffset, left: t.left + window.pageXOffset }; }, position: e => ({ top: e.offsetTop, left: e.offsetLeft }) }; const NODE_TEXT = 3; const SelectorEngine = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)), parents (e, t) { const i = []; let n = e.parentNode; for (;n && n.nodeType === Node.ELEMENT_NODE && n.nodeType !== 3;)n.matches(t) && i.push(n), n = n.parentNode; return i; }, prev (e, t) { let i = e.previousElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling; } return []; }, next (e, t) { let i = e.nextElementSibling; for (;i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling; } return []; }, focusableChildren (e) { const t = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(e => e + ':not([tabindex^="-"])').join(', '); return this.find(t, e).filter(e => !isDisabled(e) && isVisible(e)); } }; const NAME$b = 'carousel'; const DATA_KEY$a = 'bs.carousel'; const EVENT_KEY$a = '.bs.carousel'; const DATA_API_KEY$6 = '.data-api'; const ARROW_LEFT_KEY = 'ArrowLeft'; const ARROW_RIGHT_KEY = 'ArrowRight'; const TOUCHEVENT_COMPAT_WAIT = 500; const SWIPE_THRESHOLD = 40; const Default$a = { interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0 }; const DefaultType$a = { interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean' }; const ORDER_NEXT = 'next'; const ORDER_PREV = 'prev'; const DIRECTION_LEFT = 'left'; const DIRECTION_RIGHT = 'right'; const KEY_TO_DIRECTION = { ArrowLeft: DIRECTION_RIGHT, ArrowRight: DIRECTION_LEFT }; const EVENT_SLIDE = 'slide.bs.carousel'; const EVENT_SLID = 'slid.bs.carousel'; const EVENT_KEYDOWN = 'keydown.bs.carousel'; const EVENT_MOUSEENTER = 'mouseenter.bs.carousel'; const EVENT_MOUSELEAVE = 'mouseleave.bs.carousel'; const EVENT_TOUCHSTART = 'touchstart.bs.carousel'; const EVENT_TOUCHMOVE = 'touchmove.bs.carousel'; const EVENT_TOUCHEND = 'touchend.bs.carousel'; const EVENT_POINTERDOWN = 'pointerdown.bs.carousel'; const EVENT_POINTERUP = 'pointerup.bs.carousel'; const EVENT_DRAG_START = 'dragstart.bs.carousel'; const EVENT_LOAD_DATA_API$2 = 'load.bs.carousel.data-api'; const EVENT_CLICK_DATA_API$5 = 'click.bs.carousel.data-api'; const CLASS_NAME_CAROUSEL = 'carousel'; const CLASS_NAME_ACTIVE$2 = 'active'; const CLASS_NAME_SLIDE = 'slide'; const CLASS_NAME_END = 'carousel-item-end'; const CLASS_NAME_START = 'carousel-item-start'; const CLASS_NAME_NEXT = 'carousel-item-next'; const CLASS_NAME_PREV = 'carousel-item-prev'; const CLASS_NAME_POINTER_EVENT = 'pointer-event'; const SELECTOR_ACTIVE$1 = '.active'; const SELECTOR_ACTIVE_ITEM = '.active.carousel-item'; const SELECTOR_ITEM = '.carousel-item'; const SELECTOR_ITEM_IMG = '.carousel-item img'; const SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev'; const SELECTOR_INDICATORS = '.carousel-indicators'; const SELECTOR_INDICATOR = '[data-bs-target]'; const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]'; const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]'; const POINTER_TYPE_TOUCH = 'touch'; const POINTER_TYPE_PEN = 'pen'; class Carousel extends BaseComponent {constructor (e, t) { super(e), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(t), this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners(); } static get Default () { return Default$a; } static get NAME () { return NAME$b; }next () { this._slide(ORDER_NEXT); }nextWhenVisible () { !document.hidden && isVisible(this._element) && this.next(); }prev () { this._slide(ORDER_PREV); }pause (e) { e || (this._isPaused = !0), SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element) && (triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }cycle (e) { e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }to (e) { this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); const t = this._getItemIndex(this._activeElement); if (e > this._items.length - 1 || e < 0) return; if (this._isSliding) return void EventHandler.one(this._element, EVENT_SLID, () => this.to(e)); if (t === e) return this.pause(), void this.cycle(); const i = e > t ? ORDER_NEXT : ORDER_PREV; this._slide(i, this._items[e]); }_getConfig (e) { return e = { ...Default$a, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$b, e, DefaultType$a), e; }_handleSwipe () { const e = Math.abs(this.touchDeltaX); if (e <= 40) return; const t = e / this.touchDeltaX; this.touchDeltaX = 0, t && this._slide(t > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT); }_addEventListeners () { this._config.keyboard && EventHandler.on(this._element, EVENT_KEYDOWN, e => this._keydown(e)), this._config.pause === 'hover' && (EventHandler.on(this._element, EVENT_MOUSEENTER, e => this.pause(e)), EventHandler.on(this._element, EVENT_MOUSELEAVE, e => this.cycle(e))), this._config.touch && this._touchSupported && this._addTouchEventListeners(); }_addTouchEventListeners () { const e = e => { !this._pointerEvent || e.pointerType !== 'pen' && e.pointerType !== 'touch' ? this._pointerEvent || (this.touchStartX = e.touches[0].clientX) : this.touchStartX = e.clientX; }; const t = e => { this.touchDeltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this.touchStartX; }; const i = e => { !this._pointerEvent || e.pointerType !== 'pen' && e.pointerType !== 'touch' || (this.touchDeltaX = e.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(e => this.cycle(e), 500 + this._config.interval)); }; SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(e => { EventHandler.on(e, EVENT_DRAG_START, e => e.preventDefault()); }), this._pointerEvent ? (EventHandler.on(this._element, EVENT_POINTERDOWN, t => e(t)), EventHandler.on(this._element, EVENT_POINTERUP, e => i(e)), this._element.classList.add('pointer-event')) : (EventHandler.on(this._element, EVENT_TOUCHSTART, t => e(t)), EventHandler.on(this._element, EVENT_TOUCHMOVE, e => t(e)), EventHandler.on(this._element, EVENT_TOUCHEND, e => i(e))); }_keydown (e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = KEY_TO_DIRECTION[e.key]; t && (e.preventDefault(), this._slide(t)); }_getItemIndex (e) { return this._items = e && e.parentNode ? SelectorEngine.find(SELECTOR_ITEM, e.parentNode) : [], this._items.indexOf(e); }_getItemByOrder (e, t) { const i = e === ORDER_NEXT; return getNextActiveElement(this._items, t, i, this._config.wrap); }_triggerSlideEvent (e, t) { const i = this._getItemIndex(e); const n = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)); return EventHandler.trigger(this._element, EVENT_SLIDE, { relatedTarget: e, direction: t, from: n, to: i }); }_setActiveIndicatorElement (e) { if (this._indicatorsElement) { const t = SelectorEngine.findOne('.active', this._indicatorsElement); t.classList.remove('active'), t.removeAttribute('aria-current'); const i = SelectorEngine.find('[data-bs-target]', this._indicatorsElement); for (let t = 0; t < i.length; t++) if (Number.parseInt(i[t].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(e)) { i[t].classList.add('active'), i[t].setAttribute('aria-current', 'true'); break; } } }_updateInterval () { const e = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval; }_slide (e, t) { const i = this._directionToOrder(e); const n = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element); const s = this._getItemIndex(n); const o = t || this._getItemByOrder(i, n); const r = this._getItemIndex(o); const a = Boolean(this._interval); const l = i === ORDER_NEXT; const c = l ? CLASS_NAME_START : CLASS_NAME_END; const _ = l ? CLASS_NAME_NEXT : CLASS_NAME_PREV; const h = this._orderToDirection(i); if (o && o.classList.contains('active')) return void (this._isSliding = !1); if (this._isSliding) return; if (this._triggerSlideEvent(o, h).defaultPrevented) return; if (!n || !o) return; this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o; const E = () => { EventHandler.trigger(this._element, EVENT_SLID, { relatedTarget: o, direction: h, from: s, to: r }); }; if (this._element.classList.contains('slide')) { o.classList.add(_), reflow(o), n.classList.add(c), o.classList.add(c); const e = () => { o.classList.remove(c, _), o.classList.add('active'), n.classList.remove('active', _, c), this._isSliding = !1, setTimeout(E, 0); }; this._queueCallback(e, n, !0); } else n.classList.remove('active'), o.classList.add('active'), this._isSliding = !1, E(); a && this.cycle(); }_directionToOrder (e) { return [DIRECTION_RIGHT, DIRECTION_LEFT].includes(e) ? isRTL() ? e === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT : e === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV : e; }_orderToDirection (e) { return [ORDER_NEXT, ORDER_PREV].includes(e) ? isRTL() ? e === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT : e === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT : e; } static carouselInterface (e, t) { const i = Carousel.getOrCreateInstance(e, t); let { _config: n } = i; typeof t === 'object' && (n = { ...n, ...t }); const s = typeof t === 'string' ? t : n.slide; if (typeof t === 'number')i.to(t); else if (typeof s === 'string') { if (void 0 === i[s]) throw new TypeError(`No method named "${s}"`); i[s](); } else n.interval && n.ride && (i.pause(), i.cycle()); } static jQueryInterface (e) { return this.each(function () { Carousel.carouselInterface(this, e); }); } static dataApiClickHandler (e) { const t = getElementFromSelector(this); if (!t || !t.classList.contains('carousel')) return; const i = { ...Manipulator.getDataAttributes(t), ...Manipulator.getDataAttributes(this) }; const n = this.getAttribute('data-bs-slide-to'); n && (i.interval = !1), Carousel.carouselInterface(t, i), n && Carousel.getInstance(t).to(n), e.preventDefault(); }}EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler), EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => { const e = SelectorEngine.find(SELECTOR_DATA_RIDE); for (let t = 0, i = e.length; t < i; t++)Carousel.carouselInterface(e[t], Carousel.getInstance(e[t])); }), defineJQueryPlugin(Carousel); const NAME$a = 'collapse'; const DATA_KEY$9 = 'bs.collapse'; const EVENT_KEY$9 = '.bs.collapse'; const DATA_API_KEY$5 = '.data-api'; const Default$9 = { toggle: !0, parent: null }; const DefaultType$9 = { toggle: 'boolean', parent: '(null|element)' }; const EVENT_SHOW$5 = 'show.bs.collapse'; const EVENT_SHOWN$5 = 'shown.bs.collapse'; const EVENT_HIDE$5 = 'hide.bs.collapse'; const EVENT_HIDDEN$5 = 'hidden.bs.collapse'; const EVENT_CLICK_DATA_API$4 = 'click.bs.collapse.data-api'; const CLASS_NAME_SHOW$7 = 'show'; const CLASS_NAME_COLLAPSE = 'collapse'; const CLASS_NAME_COLLAPSING = 'collapsing'; const CLASS_NAME_COLLAPSED = 'collapsed'; const CLASS_NAME_HORIZONTAL = 'collapse-horizontal'; const WIDTH = 'width'; const HEIGHT = 'height'; const SELECTOR_ACTIVES = '.show, .collapsing'; const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]'; class Collapse extends BaseComponent {constructor (e, t) { super(e), this._isTransitioning = !1, this._config = this._getConfig(t), this._triggerArray = []; const i = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4); for (let e = 0, t = i.length; e < t; e++) { const t = i[e]; const n = getSelectorFromElement(t); const s = SelectorEngine.find(n).filter(e => e === this._element); n !== null && s.length && (this._selector = n, this._triggerArray.push(t)); } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle(); } static get Default () { return Default$9; } static get NAME () { return NAME$a; }toggle () { this._isShown() ? this.hide() : this.show(); }show () { if (this._isTransitioning || this._isShown()) return; let e; let t = []; if (this._config.parent) { const e = SelectorEngine.find('.collapse .collapse', this._config.parent); t = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter(t => !e.includes(t)); } const i = SelectorEngine.findOne(this._selector); if (t.length) { const n = t.find(e => i !== e); if (e = n ? Collapse.getInstance(n) : null, e && e._isTransitioning) return; } if (EventHandler.trigger(this._element, EVENT_SHOW$5).defaultPrevented) return; t.forEach(t => { i !== t && Collapse.getOrCreateInstance(t, { toggle: !1 }).hide(), e || Data.set(t, DATA_KEY$9, null); }); const n = this._getDimension(); this._element.classList.remove('collapse'), this._element.classList.add('collapsing'), this._element.style[n] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const s = 'scroll' + (n[0].toUpperCase() + n.slice(1)); this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove('collapsing'), this._element.classList.add('collapse', 'show'), this._element.style[n] = '', EventHandler.trigger(this._element, EVENT_SHOWN$5); }, this._element, !0), this._element.style[n] = this._element[s] + 'px'; }hide () { if (this._isTransitioning || !this._isShown()) return; if (EventHandler.trigger(this._element, EVENT_HIDE$5).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = this._element.getBoundingClientRect()[e] + 'px', reflow(this._element), this._element.classList.add('collapsing'), this._element.classList.remove('collapse', 'show'); const t = this._triggerArray.length; for (let e = 0; e < t; e++) { const t = this._triggerArray[e]; const i = getElementFromSelector(t); i && !this._isShown(i) && this._addAriaAndCollapsedClass([t], !1); } this._isTransitioning = !0, this._element.style[e] = '', this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove('collapsing'), this._element.classList.add('collapse'), EventHandler.trigger(this._element, EVENT_HIDDEN$5); }, this._element, !0); }_isShown (e = this._element) { return e.classList.contains('show'); }_getConfig (e) { return (e = { ...Default$9, ...Manipulator.getDataAttributes(this._element), ...e }).toggle = Boolean(e.toggle), e.parent = getElement(e.parent), typeCheckConfig(NAME$a, e, DefaultType$9), e; }_getDimension () { return this._element.classList.contains('collapse-horizontal') ? WIDTH : HEIGHT; }_initializeChildren () { if (!this._config.parent) return; const e = SelectorEngine.find('.collapse .collapse', this._config.parent); SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter(t => !e.includes(t)).forEach(e => { const t = getElementFromSelector(e); t && this._addAriaAndCollapsedClass([e], this._isShown(t)); }); }_addAriaAndCollapsedClass (e, t) { e.length && e.forEach(e => { t ? e.classList.remove('collapsed') : e.classList.add('collapsed'), e.setAttribute('aria-expanded', t); }); } static jQueryInterface (e) { return this.each(function () { const t = {}; typeof e === 'string' && /show|hide/.test(e) && (t.toggle = !1); const i = Collapse.getOrCreateInstance(this, t); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e](); } }); }}EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (e) { (e.target.tagName === 'A' || e.delegateTarget && e.delegateTarget.tagName === 'A') && e.preventDefault(); const t = getSelectorFromElement(this); SelectorEngine.find(t).forEach(e => { Collapse.getOrCreateInstance(e, { toggle: !1 }).toggle(); }); }), defineJQueryPlugin(Collapse); const NAME$9 = 'dropdown'; const DATA_KEY$8 = 'bs.dropdown'; const EVENT_KEY$8 = '.bs.dropdown'; const DATA_API_KEY$4 = '.data-api'; const ESCAPE_KEY$2 = 'Escape'; const SPACE_KEY = 'Space'; const TAB_KEY$1 = 'Tab'; const ARROW_UP_KEY = 'ArrowUp'; const ARROW_DOWN_KEY = 'ArrowDown'; const RIGHT_MOUSE_BUTTON = 2; const REGEXP_KEYDOWN = new RegExp('ArrowUp|ArrowDown|Escape'); const EVENT_HIDE$4 = 'hide.bs.dropdown'; const EVENT_HIDDEN$4 = 'hidden.bs.dropdown'; const EVENT_SHOW$4 = 'show.bs.dropdown'; const EVENT_SHOWN$4 = 'shown.bs.dropdown'; const EVENT_CLICK_DATA_API$3 = 'click.bs.dropdown.data-api'; const EVENT_KEYDOWN_DATA_API = 'keydown.bs.dropdown.data-api'; const EVENT_KEYUP_DATA_API = 'keyup.bs.dropdown.data-api'; const CLASS_NAME_SHOW$6 = 'show'; const CLASS_NAME_DROPUP = 'dropup'; const CLASS_NAME_DROPEND = 'dropend'; const CLASS_NAME_DROPSTART = 'dropstart'; const CLASS_NAME_NAVBAR = 'navbar'; const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]'; const SELECTOR_MENU = '.dropdown-menu'; const SELECTOR_NAVBAR_NAV = '.navbar-nav'; const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'; const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start'; const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end'; const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start'; const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end'; const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start'; const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start'; const Default$8 = { offset: [0, 2], boundary: 'clippingParents', reference: 'toggle', display: 'dynamic', popperConfig: null, autoClose: !0 }; const DefaultType$8 = { offset: '(array|string|function)', boundary: '(string|element)', reference: '(string|element|object)', display: 'string', popperConfig: '(null|object|function)', autoClose: '(boolean|string)' }; class Dropdown extends BaseComponent {constructor (e, t) { super(e), this._popper = null, this._config = this._getConfig(t), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(); } static get Default () { return Default$8; } static get DefaultType () { return DefaultType$8; } static get NAME () { return NAME$9; }toggle () { return this._isShown() ? this.hide() : this.show(); }show () { if (isDisabled(this._element) || this._isShown(this._menu)) return; const e = { relatedTarget: this._element }; if (EventHandler.trigger(this._element, EVENT_SHOW$4, e).defaultPrevented) return; const t = Dropdown.getParentFromElement(this._element); this._inNavbar ? Manipulator.setDataAttribute(this._menu, 'popper', 'none') : this._createPopper(t), 'ontouchstart' in document.documentElement && !t.closest('.navbar-nav') && [].concat(...document.body.children).forEach(e => EventHandler.on(e, 'mouseover', noop)), this._element.focus(), this._element.setAttribute('aria-expanded', !0), this._menu.classList.add('show'), this._element.classList.add('show'), EventHandler.trigger(this._element, EVENT_SHOWN$4, e); }hide () { if (isDisabled(this._element) || !this._isShown(this._menu)) return; const e = { relatedTarget: this._element }; this._completeHide(e); }dispose () { this._popper && this._popper.destroy(), super.dispose(); }update () { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update(); }_completeHide (e) { EventHandler.trigger(this._element, EVENT_HIDE$4, e).defaultPrevented || ('ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach(e => EventHandler.off(e, 'mouseover', noop)), this._popper && this._popper.destroy(), this._menu.classList.remove('show'), this._element.classList.remove('show'), this._element.setAttribute('aria-expanded', 'false'), Manipulator.removeDataAttribute(this._menu, 'popper'), EventHandler.trigger(this._element, EVENT_HIDDEN$4, e)); }_getConfig (e) { if (e = { ...this.constructor.Default, ...Manipulator.getDataAttributes(this._element), ...e }, typeCheckConfig(NAME$9, e, this.constructor.DefaultType), typeof e.reference === 'object' && !isElement(e.reference) && typeof e.reference.getBoundingClientRect !== 'function') throw new TypeError(NAME$9.toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.'); return e; }_createPopper (e) { if (void 0 === Popper) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; this._config.reference === 'parent' ? t = e : isElement(this._config.reference) ? t = getElement(this._config.reference) : typeof this._config.reference === 'object' && (t = this._config.reference); const i = this._getPopperConfig(); const n = i.modifiers.find(e => e.name === 'applyStyles' && !1 === e.enabled); this._popper = Popper.createPopper(t, this._menu, i), n && Manipulator.setDataAttribute(this._menu, 'popper', 'static'); }_isShown (e = this._element) { return e.classList.contains('show'); }_getMenuElement () { return SelectorEngine.next(this._element, SELECTOR_MENU)[0]; }_getPlacement () { const e = this._element.parentNode; if (e.classList.contains('dropend')) return PLACEMENT_RIGHT; if (e.classList.contains('dropstart')) return PLACEMENT_LEFT; const t = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end'; return e.classList.contains('dropup') ? t ? PLACEMENT_TOPEND : PLACEMENT_TOP : t ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM; }_detectNavbar () { return this._element.closest('.navbar') !== null; }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e; }_getPopperConfig () { const e = { placement: this._getPlacement(), modifiers: [{ name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'offset', options: { offset: this._getOffset() } }] }; return this._config.display === 'static' && (e.modifiers = [{ name: 'applyStyles', enabled: !1 }]), { ...e, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(e) : this._config.popperConfig }; }_selectMenuItem ({ key: e, target: t }) { const i = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible); i.length && getNextActiveElement(i, t, e === 'ArrowDown', !i.includes(t)).focus(); } static jQueryInterface (e) { return this.each(function () { const t = Dropdown.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } }); } static clearMenus (e) { if (e && (e.button === 2 || e.type === 'keyup' && e.key !== 'Tab')) return; const t = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3); for (let i = 0, n = t.length; i < n; i++) { const n = Dropdown.getInstance(t[i]); if (!n || !1 === n._config.autoClose) continue; if (!n._isShown()) continue; const s = { relatedTarget: n._element }; if (e) { const t = e.composedPath(); const i = t.includes(n._menu); if (t.includes(n._element) || n._config.autoClose === 'inside' && !i || n._config.autoClose === 'outside' && i) continue; if (n._menu.contains(e.target) && (e.type === 'keyup' && e.key === 'Tab' || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; e.type === 'click' && (s.clickEvent = e); }n._completeHide(s); } } static getParentFromElement (e) { return getElementFromSelector(e) || e.parentNode; } static dataApiKeydownHandler (e) { if (/input|textarea/i.test(e.target.tagName) ? e.key === 'Space' || e.key !== 'Escape' && (e.key !== 'ArrowDown' && e.key !== 'ArrowUp' || e.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(e.key)) return; const t = this.classList.contains('show'); if (!t && e.key === 'Escape') return; if (e.preventDefault(), e.stopPropagation(), isDisabled(this)) return; const i = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0]; const n = Dropdown.getOrCreateInstance(i); if (e.key !== 'Escape') return e.key === 'ArrowUp' || e.key === 'ArrowDown' ? (t || n.show(), void n._selectMenuItem(e)) : void (t && e.key !== 'Space' || Dropdown.clearMenus()); n.hide(); }}EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler), EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler), EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus), EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus), EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (e) { e.preventDefault(), Dropdown.getOrCreateInstance(this).toggle(); }), defineJQueryPlugin(Dropdown); const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const SELECTOR_STICKY_CONTENT = '.sticky-top'; class ScrollBarHelper {constructor () { this._element = document.body; }getWidth () { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e); }hide () { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, 'paddingRight', t => t + e), this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', t => t + e), this._setElementAttributes('.sticky-top', 'marginRight', t => t - e); }_disableOverFlow () { this._saveInitialAttribute(this._element, 'overflow'), this._element.style.overflow = 'hidden'; }_setElementAttributes (e, t, i) { const n = this.getWidth(); this._applyManipulationCallback(e, e => { if (e !== this._element && window.innerWidth > e.clientWidth + n) return; this._saveInitialAttribute(e, t); const s = window.getComputedStyle(e)[t]; e.style[t] = i(Number.parseFloat(s)) + 'px'; }); }reset () { this._resetElementAttributes(this._element, 'overflow'), this._resetElementAttributes(this._element, 'paddingRight'), this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight'), this._resetElementAttributes('.sticky-top', 'marginRight'); }_saveInitialAttribute (e, t) { const i = e.style[t]; i && Manipulator.setDataAttribute(e, t, i); }_resetElementAttributes (e, t) { this._applyManipulationCallback(e, e => { const i = Manipulator.getDataAttribute(e, t); void 0 === i ? e.style.removeProperty(t) : (Manipulator.removeDataAttribute(e, t), e.style[t] = i); }); }_applyManipulationCallback (e, t) { isElement(e) ? t(e) : SelectorEngine.find(e, this._element).forEach(t); }isOverflowing () { return this.getWidth() > 0; }} const Default$7 = { className: 'modal-backdrop', isVisible: !0, isAnimated: !1, rootElement: 'body', clickCallback: null }; const DefaultType$7 = { className: 'string', isVisible: 'boolean', isAnimated: 'boolean', rootElement: '(element|string)', clickCallback: '(function|null)' }; const NAME$8 = 'backdrop'; const CLASS_NAME_FADE$4 = 'fade'; const CLASS_NAME_SHOW$5 = 'show'; const EVENT_MOUSEDOWN = 'mousedown.bs.backdrop'; class Backdrop {constructor (e) { this._config = this._getConfig(e), this._isAppended = !1, this._element = null; }show (e) { this._config.isVisible ? (this._append(), this._config.isAnimated && reflow(this._getElement()), this._getElement().classList.add('show'), this._emulateAnimation(() => { execute(e); })) : execute(e); }hide (e) { this._config.isVisible ? (this._getElement().classList.remove('show'), this._emulateAnimation(() => { this.dispose(), execute(e); })) : execute(e); }_getElement () { if (!this._element) { const e = document.createElement('div'); e.className = this._config.className, this._config.isAnimated && e.classList.add('fade'), this._element = e; } return this._element; }_getConfig (e) { return (e = { ...Default$7, ...typeof e === 'object' ? e : {} }).rootElement = getElement(e.rootElement), typeCheckConfig(NAME$8, e, DefaultType$7), e; }_append () { this._isAppended || (this._config.rootElement.append(this._getElement()), EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => { execute(this._config.clickCallback); }), this._isAppended = !0); }dispose () { this._isAppended && (EventHandler.off(this._element, EVENT_MOUSEDOWN), this._element.remove(), this._isAppended = !1); }_emulateAnimation (e) { executeAfterTransition(e, this._getElement(), this._config.isAnimated); }} const Default$6 = { trapElement: null, autofocus: !0 }; const DefaultType$6 = { trapElement: 'element', autofocus: 'boolean' }; const NAME$7 = 'focustrap'; const DATA_KEY$7 = 'bs.focustrap'; const EVENT_KEY$7 = '.bs.focustrap'; const EVENT_FOCUSIN$1 = 'focusin.bs.focustrap'; const EVENT_KEYDOWN_TAB = 'keydown.tab.bs.focustrap'; const TAB_KEY = 'Tab'; const TAB_NAV_FORWARD = 'forward'; const TAB_NAV_BACKWARD = 'backward'; class FocusTrap {constructor (e) { this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null; }activate () { const { trapElement: e, autofocus: t } = this._config; this._isActive || (t && e.focus(), EventHandler.off(document, EVENT_KEY$7), EventHandler.on(document, EVENT_FOCUSIN$1, e => this._handleFocusin(e)), EventHandler.on(document, EVENT_KEYDOWN_TAB, e => this._handleKeydown(e)), this._isActive = !0); }deactivate () { this._isActive && (this._isActive = !1, EventHandler.off(document, EVENT_KEY$7)); }_handleFocusin (e) { const { target: t } = e; const { trapElement: i } = this._config; if (t === document || t === i || i.contains(t)) return; const n = SelectorEngine.focusableChildren(i); n.length === 0 ? i.focus() : this._lastTabNavDirection === 'backward' ? n[n.length - 1].focus() : n[0].focus(); }_handleKeydown (e) { e.key === 'Tab' && (this._lastTabNavDirection = e.shiftKey ? 'backward' : 'forward'); }_getConfig (e) { return e = { ...Default$6, ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$7, e, DefaultType$6), e; }} const NAME$6 = 'modal'; const DATA_KEY$6 = 'bs.modal'; const EVENT_KEY$6 = '.bs.modal'; const DATA_API_KEY$3 = '.data-api'; const ESCAPE_KEY$1 = 'Escape'; const Default$5 = { backdrop: !0, keyboard: !0, focus: !0 }; const DefaultType$5 = { backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean' }; const EVENT_HIDE$3 = 'hide.bs.modal'; const EVENT_HIDE_PREVENTED = 'hidePrevented.bs.modal'; const EVENT_HIDDEN$3 = 'hidden.bs.modal'; const EVENT_SHOW$3 = 'show.bs.modal'; const EVENT_SHOWN$3 = 'shown.bs.modal'; const EVENT_RESIZE = 'resize.bs.modal'; const EVENT_CLICK_DISMISS = 'click.dismiss.bs.modal'; const EVENT_KEYDOWN_DISMISS$1 = 'keydown.dismiss.bs.modal'; const EVENT_MOUSEUP_DISMISS = 'mouseup.dismiss.bs.modal'; const EVENT_MOUSEDOWN_DISMISS = 'mousedown.dismiss.bs.modal'; const EVENT_CLICK_DATA_API$2 = 'click.bs.modal.data-api'; const CLASS_NAME_OPEN = 'modal-open'; const CLASS_NAME_FADE$3 = 'fade'; const CLASS_NAME_SHOW$4 = 'show'; const CLASS_NAME_STATIC = 'modal-static'; const SELECTOR_DIALOG = '.modal-dialog'; const SELECTOR_MODAL_BODY = '.modal-body'; const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]'; class Modal extends BaseComponent {constructor (e, t) { super(e), this._config = this._getConfig(t), this._dialog = SelectorEngine.findOne('.modal-dialog', this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ScrollBarHelper(); } static get Default () { return Default$5; } static get NAME () { return NAME$6; }toggle (e) { return this._isShown ? this.hide() : this.show(e); }show (e) { this._isShown || this._isTransitioning || EventHandler.trigger(this._element, EVENT_SHOW$3, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add('modal-open'), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => { EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, e => { e.target === this._element && (this._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => this._showElement(e))); }hide () { if (!this._isShown || this._isTransitioning) return; if (EventHandler.trigger(this._element, EVENT_HIDE$3).defaultPrevented) return; this._isShown = !1; const e = this._isAnimated(); e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove('show'), EventHandler.off(this._element, EVENT_CLICK_DISMISS), EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS), this._queueCallback(() => this._hideModal(), this._element, e); }dispose () { [window, this._dialog].forEach(e => EventHandler.off(e, '.bs.modal')), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }handleUpdate () { this._adjustDialog(); }_initializeBackDrop () { return new Backdrop({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }); }_initializeFocusTrap () { return new FocusTrap({ trapElement: this._element }); }_getConfig (e) { return e = { ...Default$5, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$6, e, DefaultType$5), e; }_showElement (e) { const t = this._isAnimated(); const i = SelectorEngine.findOne('.modal-body', this._dialog); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.scrollTop = 0, i && (i.scrollTop = 0), t && reflow(this._element), this._element.classList.add('show'), this._queueCallback(() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, EventHandler.trigger(this._element, EVENT_SHOWN$3, { relatedTarget: e }); }, this._dialog, t); }_setEscapeEvent () { this._isShown ? EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, e => { this._config.keyboard && e.key === 'Escape' ? (e.preventDefault(), this.hide()) : this._config.keyboard || e.key !== 'Escape' || this._triggerBackdropTransition(); }) : EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1); }_setResizeEvent () { this._isShown ? EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog()) : EventHandler.off(window, EVENT_RESIZE); }_hideModal () { this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove('modal-open'), this._resetAdjustments(), this._scrollBar.reset(), EventHandler.trigger(this._element, EVENT_HIDDEN$3); }); }_showBackdrop (e) { EventHandler.on(this._element, EVENT_CLICK_DISMISS, e => { this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : e.target === e.currentTarget && (!0 === this._config.backdrop ? this.hide() : this._config.backdrop === 'static' && this._triggerBackdropTransition()); }), this._backdrop.show(e); }_isAnimated () { return this._element.classList.contains('fade'); }_triggerBackdropTransition () { if (EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED).defaultPrevented) return; const { classList: e, scrollHeight: t, style: i } = this._element; const n = t > document.documentElement.clientHeight; !n && i.overflowY === 'hidden' || e.contains('modal-static') || (n || (i.overflowY = 'hidden'), e.add('modal-static'), this._queueCallback(() => { e.remove('modal-static'), n || this._queueCallback(() => { i.overflowY = ''; }, this._dialog); }, this._dialog), this._element.focus()); }_adjustDialog () { const e = this._element.scrollHeight > document.documentElement.clientHeight; const t = this._scrollBar.getWidth(); const i = t > 0; (!i && e && !isRTL() || i && !e && isRTL()) && (this._element.style.paddingLeft = t + 'px'), (i && !e && !isRTL() || !i && e && isRTL()) && (this._element.style.paddingRight = t + 'px'); }_resetAdjustments () { this._element.style.paddingLeft = '', this._element.style.paddingRight = ''; } static jQueryInterface (e, t) { return this.each(function () { const i = Modal.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e](t); } }); }}EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (e) { const t = getElementFromSelector(this); ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), EventHandler.one(t, EVENT_SHOW$3, e => { e.defaultPrevented || EventHandler.one(t, EVENT_HIDDEN$3, () => { isVisible(this) && this.focus(); }); }), Modal.getOrCreateInstance(t).toggle(this); }), enableDismissTrigger(Modal), defineJQueryPlugin(Modal); const NAME$5 = 'offcanvas'; const DATA_KEY$5 = 'bs.offcanvas'; const EVENT_KEY$5 = '.bs.offcanvas'; const DATA_API_KEY$2 = '.data-api'; const EVENT_LOAD_DATA_API$1 = 'load.bs.offcanvas.data-api'; const ESCAPE_KEY = 'Escape'; const Default$4 = { backdrop: !0, keyboard: !0, scroll: !1 }; const DefaultType$4 = { backdrop: 'boolean', keyboard: 'boolean', scroll: 'boolean' }; const CLASS_NAME_SHOW$3 = 'show'; const CLASS_NAME_BACKDROP = 'offcanvas-backdrop'; const OPEN_SELECTOR = '.offcanvas.show'; const EVENT_SHOW$2 = 'show.bs.offcanvas'; const EVENT_SHOWN$2 = 'shown.bs.offcanvas'; const EVENT_HIDE$2 = 'hide.bs.offcanvas'; const EVENT_HIDDEN$2 = 'hidden.bs.offcanvas'; const EVENT_CLICK_DATA_API$1 = 'click.bs.offcanvas.data-api'; const EVENT_KEYDOWN_DISMISS = 'keydown.dismiss.bs.offcanvas'; const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]'; class Offcanvas extends BaseComponent {constructor (e, t) { super(e), this._config = this._getConfig(t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(); } static get NAME () { return NAME$5; } static get Default () { return Default$4; }toggle (e) { return this._isShown ? this.hide() : this.show(e); }show (e) { this._isShown || EventHandler.trigger(this._element, EVENT_SHOW$2, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = 'visible', this._backdrop.show(), this._config.scroll || (new ScrollBarHelper()).hide(), this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), this._element.setAttribute('role', 'dialog'), this._element.classList.add('show'), this._queueCallback(() => { this._config.scroll || this._focustrap.activate(), EventHandler.trigger(this._element, EVENT_SHOWN$2, { relatedTarget: e }); }, this._element, !0)); }hide () { this._isShown && (EventHandler.trigger(this._element, EVENT_HIDE$2).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove('show'), this._backdrop.hide(), this._queueCallback(() => { this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._element.removeAttribute('role'), this._element.style.visibility = 'hidden', this._config.scroll || (new ScrollBarHelper()).reset(), EventHandler.trigger(this._element, EVENT_HIDDEN$2); }, this._element, !0))); }dispose () { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }_getConfig (e) { return e = { ...Default$4, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' ? e : {} }, typeCheckConfig(NAME$5, e, DefaultType$4), e; }_initializeBackDrop () { return new Backdrop({ className: CLASS_NAME_BACKDROP, isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide() }); }_initializeFocusTrap () { return new FocusTrap({ trapElement: this._element }); }_addEventListeners () { EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, e => { this._config.keyboard && e.key === 'Escape' && this.hide(); }); } static jQueryInterface (e) { return this.each(function () { const t = Offcanvas.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](this); } }); }}EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (e) { const t = getElementFromSelector(this); if (['A', 'AREA'].includes(this.tagName) && e.preventDefault(), isDisabled(this)) return; EventHandler.one(t, EVENT_HIDDEN$2, () => { isVisible(this) && this.focus(); }); const i = SelectorEngine.findOne(OPEN_SELECTOR); i && i !== t && Offcanvas.getInstance(i).hide(), Offcanvas.getOrCreateInstance(t).toggle(this); }), EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => SelectorEngine.find(OPEN_SELECTOR).forEach(e => Offcanvas.getOrCreateInstance(e).show())), enableDismissTrigger(Offcanvas), defineJQueryPlugin(Offcanvas); const uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']); const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i; const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i; const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const allowedAttribute = (e, t) => { const i = e.nodeName.toLowerCase(); if (t.includes(i)) return !uriAttrs.has(i) || Boolean(SAFE_URL_PATTERN.test(e.nodeValue) || DATA_URL_PATTERN.test(e.nodeValue)); const n = t.filter(e => e instanceof RegExp); for (let e = 0, t = n.length; e < t; e++) if (n[e].test(i)) return !0; return !1; }; const DefaultAllowlist = { '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'srcset', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; function sanitizeHtml (e, t, i) { if (!e.length) return e; if (i && typeof i === 'function') return i(e); const n = (new window.DOMParser()).parseFromString(e, 'text/html'); const s = Object.keys(t); const o = [].concat(...n.body.querySelectorAll('*')); for (let e = 0, i = o.length; e < i; e++) { const i = o[e]; const n = i.nodeName.toLowerCase(); if (!s.includes(n)) { i.remove(); continue; } const r = [].concat(...i.attributes); const a = [].concat(t['*'] || [], t[n] || []); r.forEach(e => { allowedAttribute(e, a) || i.removeAttribute(e.nodeName); }); } return n.body.innerHTML; } const NAME$4 = 'tooltip'; const DATA_KEY$4 = 'bs.tooltip'; const EVENT_KEY$4 = '.bs.tooltip'; const CLASS_PREFIX$1 = 'bs-tooltip'; const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']); const DefaultType$3 = { animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(array|string|function)', container: '(string|element|boolean)', fallbackPlacements: 'array', boundary: '(string|element)', customClass: '(string|function)', sanitize: 'boolean', sanitizeFn: '(null|function)', allowList: 'object', popperConfig: '(null|object|function)' }; const AttachmentMap = { AUTO: 'auto', TOP: 'top', RIGHT: isRTL() ? 'left' : 'right', BOTTOM: 'bottom', LEFT: isRTL() ? 'right' : 'left' }; const Default$3 = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, selector: !1, placement: 'top', offset: [0, 0], container: !1, fallbackPlacements: ['top', 'right', 'bottom', 'left'], boundary: 'clippingParents', customClass: '', sanitize: !0, sanitizeFn: null, allowList: DefaultAllowlist, popperConfig: null }; const Event$2 = { HIDE: 'hide.bs.tooltip', HIDDEN: 'hidden.bs.tooltip', SHOW: 'show.bs.tooltip', SHOWN: 'shown.bs.tooltip', INSERTED: 'inserted.bs.tooltip', CLICK: 'click.bs.tooltip', FOCUSIN: 'focusin.bs.tooltip', FOCUSOUT: 'focusout.bs.tooltip', MOUSEENTER: 'mouseenter.bs.tooltip', MOUSELEAVE: 'mouseleave.bs.tooltip' }; const CLASS_NAME_FADE$2 = 'fade'; const CLASS_NAME_MODAL = 'modal'; const CLASS_NAME_SHOW$2 = 'show'; const HOVER_STATE_SHOW = 'show'; const HOVER_STATE_OUT = 'out'; const SELECTOR_TOOLTIP_INNER = '.tooltip-inner'; const SELECTOR_MODAL = '.modal'; const EVENT_MODAL_HIDE = 'hide.bs.modal'; const TRIGGER_HOVER = 'hover'; const TRIGGER_FOCUS = 'focus'; const TRIGGER_CLICK = 'click'; const TRIGGER_MANUAL = 'manual'; class Tooltip extends BaseComponent {constructor (e, t) { if (void 0 === Popper) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e), this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(t), this.tip = null, this._setListeners(); } static get Default () { return Default$3; } static get NAME () { return NAME$4; } static get Event () { return Event$2; } static get DefaultType () { return DefaultType$3; }enable () { this._isEnabled = !0; }disable () { this._isEnabled = !1; }toggleEnabled () { this._isEnabled = !this._isEnabled; }toggle (e) { if (this._isEnabled) if (e) { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger.click = !t._activeTrigger.click, t._isWithActiveTrigger() ? t._enter(null, t) : t._leave(null, t); } else { if (this.getTipElement().classList.contains('show')) return void this._leave(null, this); this._enter(null, this); } }dispose () { clearTimeout(this._timeout), EventHandler.off(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose(); }show () { if (this._element.style.display === 'none') throw new Error('Please use show on visible elements'); if (!this.isWithContent() || !this._isEnabled) return; const e = EventHandler.trigger(this._element, this.constructor.Event.SHOW); const t = findShadowRoot(this._element); const i = t === null ? this._element.ownerDocument.documentElement.contains(this._element) : t.contains(this._element); if (e.defaultPrevented || !i) return; const n = this.getTipElement(); const s = getUID(this.constructor.NAME); n.setAttribute('id', s), this._element.setAttribute('aria-describedby', s), this._config.animation && n.classList.add('fade'); const o = typeof this._config.placement === 'function' ? this._config.placement.call(this, n, this._element) : this._config.placement; const r = this._getAttachment(o); this._addAttachmentClass(r); const { container: a } = this._config; Data.set(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.append(n), EventHandler.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Popper.createPopper(this._element, n, this._getPopperConfig(r)), n.classList.add('show'); const l = this._resolvePossibleFunction(this._config.customClass); l && n.classList.add(...l.split(' ')), 'ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach(e => { EventHandler.on(e, 'mouseover', noop); }); const c = this.tip.classList.contains('fade'); this._queueCallback(() => { const e = this._hoverState; this._hoverState = null, EventHandler.trigger(this._element, this.constructor.Event.SHOWN), e === 'out' && this._leave(null, this); }, this.tip, c); }hide () { if (!this._popper) return; const e = this.getTipElement(); if (EventHandler.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; e.classList.remove('show'), 'ontouchstart' in document.documentElement && [].concat(...document.body.children).forEach(e => EventHandler.off(e, 'mouseover', noop)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1; const t = this.tip.classList.contains('fade'); this._queueCallback(() => { this._isWithActiveTrigger() || (this._hoverState !== 'show' && e.remove(), this._cleanTipClass(), this._element.removeAttribute('aria-describedby'), EventHandler.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null)); }, this.tip, t), this._hoverState = ''; }update () { this._popper !== null && this._popper.update(); }isWithContent () { return Boolean(this.getTitle()); }getTipElement () { if (this.tip) return this.tip; const e = document.createElement('div'); e.innerHTML = this._config.template; const t = e.children[0]; return this.setContent(t), t.classList.remove('fade', 'show'), this.tip = t, this.tip; }setContent (e) { this._sanitizeAndSetContent(e, this.getTitle(), '.tooltip-inner'); }_sanitizeAndSetContent (e, t, i) { const n = SelectorEngine.findOne(i, e); t || !n ? this.setElementContent(n, t) : n.remove(); }setElementContent (e, t) { if (e !== null) return isElement(t) ? (t = getElement(t), void (this._config.html ? t.parentNode !== e && (e.innerHTML = '', e.append(t)) : e.textContent = t.textContent)) : void (this._config.html ? (this._config.sanitize && (t = sanitizeHtml(t, this._config.allowList, this._config.sanitizeFn)), e.innerHTML = t) : e.textContent = t); }getTitle () { const e = this._element.getAttribute('data-bs-original-title') || this._config.title; return this._resolvePossibleFunction(e); }updateAttachment (e) { return e === 'right' ? 'end' : e === 'left' ? 'start' : e; }_initializeOnDelegatedTarget (e, t) { return t || this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()); }_getOffset () { const { offset: e } = this._config; return typeof e === 'string' ? e.split(',').map(e => Number.parseInt(e, 10)) : typeof e === 'function' ? t => e(t, this._element) : e; }_resolvePossibleFunction (e) { return typeof e === 'function' ? e.call(this._element) : e; }_getPopperConfig (e) { const t = { placement: e, modifiers: [{ name: 'flip', options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: 'offset', options: { offset: this._getOffset() } }, { name: 'preventOverflow', options: { boundary: this._config.boundary } }, { name: 'arrow', options: { element: `.${this.constructor.NAME}-arrow` } }, { name: 'onChange', enabled: !0, phase: 'afterWrite', fn: e => this._handlePopperPlacementChange(e) }], onFirstUpdate: e => { e.options.placement !== e.placement && this._handlePopperPlacementChange(e); } }; return { ...t, ...typeof this._config.popperConfig === 'function' ? this._config.popperConfig(t) : this._config.popperConfig }; }_addAttachmentClass (e) { this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(e)}`); }_getAttachment (e) { return AttachmentMap[e.toUpperCase()]; }_setListeners () { this._config.trigger.split(' ').forEach(e => { if (e === 'click')EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, e => this.toggle(e)); else if (e !== 'manual') { const t = e === 'hover' ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN; const i = e === 'hover' ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; EventHandler.on(this._element, t, this._config.selector, e => this._enter(e)), EventHandler.on(this._element, i, this._config.selector, e => this._leave(e)); } }), this._hideModalHandler = () => { this._element && this.hide(); }, EventHandler.on(this._element.closest('.modal'), 'hide.bs.modal', this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: 'manual', selector: '' } : this._fixTitle(); }_fixTitle () { const e = this._element.getAttribute('title'); const t = typeof this._element.getAttribute('data-bs-original-title'); (e || t !== 'string') && (this._element.setAttribute('data-bs-original-title', e || ''), !e || this._element.getAttribute('aria-label') || this._element.textContent || this._element.setAttribute('aria-label', e), this._element.setAttribute('title', '')); }_enter (e, t) { t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger[e.type === 'focusin' ? 'focus' : 'hover'] = !0), t.getTipElement().classList.contains('show') || t._hoverState === 'show' ? t._hoverState = 'show' : (clearTimeout(t._timeout), t._hoverState = 'show', t._config.delay && t._config.delay.show ? t._timeout = setTimeout(() => { t._hoverState === 'show' && t.show(); }, t._config.delay.show) : t.show()); }_leave (e, t) { t = this._initializeOnDelegatedTarget(e, t), e && (t._activeTrigger[e.type === 'focusout' ? 'focus' : 'hover'] = t._element.contains(e.relatedTarget)), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = 'out', t._config.delay && t._config.delay.hide ? t._timeout = setTimeout(() => { t._hoverState === 'out' && t.hide(); }, t._config.delay.hide) : t.hide()); }_isWithActiveTrigger () { for (const e in this._activeTrigger) if (this._activeTrigger[e]) return !0; return !1; }_getConfig (e) { const t = Manipulator.getDataAttributes(this._element); return Object.keys(t).forEach(e => { DISALLOWED_ATTRIBUTES.has(e) && delete t[e]; }), (e = { ...this.constructor.Default, ...t, ...typeof e === 'object' && e ? e : {} }).container = !1 === e.container ? document.body : getElement(e.container), typeof e.delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title === 'number' && (e.title = e.title.toString()), typeof e.content === 'number' && (e.content = e.content.toString()), typeCheckConfig(NAME$4, e, this.constructor.DefaultType), e.sanitize && (e.template = sanitizeHtml(e.template, e.allowList, e.sanitizeFn)), e; }_getDelegateConfig () { const e = {}; for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e; }_cleanTipClass () { const e = this.getTipElement(); const t = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, 'g'); const i = e.getAttribute('class').match(t); i !== null && i.length > 0 && i.map(e => e.trim()).forEach(t => e.classList.remove(t)); }_getBasicClassPrefix () { return 'bs-tooltip'; }_handlePopperPlacementChange (e) { const { state: t } = e; t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement))); } static jQueryInterface (e) { return this.each(function () { const t = Tooltip.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } }); }}defineJQueryPlugin(Tooltip); const NAME$3 = 'popover'; const DATA_KEY$3 = 'bs.popover'; const EVENT_KEY$3 = '.bs.popover'; const CLASS_PREFIX = 'bs-popover'; const Default$2 = { ...Tooltip.Default, placement: 'right', offset: [0, 8], trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }; const DefaultType$2 = { ...Tooltip.DefaultType, content: '(string|element|function)' }; const Event$1 = { HIDE: 'hide.bs.popover', HIDDEN: 'hidden.bs.popover', SHOW: 'show.bs.popover', SHOWN: 'shown.bs.popover', INSERTED: 'inserted.bs.popover', CLICK: 'click.bs.popover', FOCUSIN: 'focusin.bs.popover', FOCUSOUT: 'focusout.bs.popover', MOUSEENTER: 'mouseenter.bs.popover', MOUSELEAVE: 'mouseleave.bs.popover' }; const SELECTOR_TITLE = '.popover-header'; const SELECTOR_CONTENT = '.popover-body'; class Popover extends Tooltip {static get Default () { return Default$2; } static get NAME () { return NAME$3; } static get Event () { return Event$1; } static get DefaultType () { return DefaultType$2; }isWithContent () { return this.getTitle() || this._getContent(); }setContent (e) { this._sanitizeAndSetContent(e, this.getTitle(), SELECTOR_TITLE), this._sanitizeAndSetContent(e, this._getContent(), '.popover-body'); }_getContent () { return this._resolvePossibleFunction(this._config.content); }_getBasicClassPrefix () { return 'bs-popover'; } static jQueryInterface (e) { return this.each(function () { const t = Popover.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } }); }}defineJQueryPlugin(Popover); const NAME$2 = 'scrollspy'; const DATA_KEY$2 = 'bs.scrollspy'; const EVENT_KEY$2 = '.bs.scrollspy'; const DATA_API_KEY$1 = '.data-api'; const Default$1 = { offset: 10, method: 'auto', target: '' }; const DefaultType$1 = { offset: 'number', method: 'string', target: '(string|element)' }; const EVENT_ACTIVATE = 'activate.bs.scrollspy'; const EVENT_SCROLL = 'scroll.bs.scrollspy'; const EVENT_LOAD_DATA_API = 'load.bs.scrollspy.data-api'; const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item'; const CLASS_NAME_ACTIVE$1 = 'active'; const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]'; const SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group'; const SELECTOR_NAV_LINKS = '.nav-link'; const SELECTOR_NAV_ITEMS = '.nav-item'; const SELECTOR_LIST_ITEMS = '.list-group-item'; const SELECTOR_LINK_ITEMS = '.nav-link, .list-group-item, .dropdown-item'; const SELECTOR_DROPDOWN$1 = '.dropdown'; const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle'; const METHOD_OFFSET = 'offset'; const METHOD_POSITION = 'position'; class ScrollSpy extends BaseComponent {constructor (e, t) { super(e), this._scrollElement = this._element.tagName === 'BODY' ? window : this._element, this._config = this._getConfig(t), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process()), this.refresh(), this._process(); } static get Default () { return Default$1; } static get NAME () { return NAME$2; }refresh () { const e = this._scrollElement === this._scrollElement.window ? 'offset' : 'position'; const t = this._config.method === 'auto' ? e : this._config.method; const i = t === 'position' ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).map(e => { const n = getSelectorFromElement(e); const s = n ? SelectorEngine.findOne(n) : null; if (s) { const e = s.getBoundingClientRect(); if (e.width || e.height) return [Manipulator[t](s).top + i, n]; } return null; }).filter(e => e).sort((e, t) => e[0] - t[0]).forEach(e => { this._offsets.push(e[0]), this._targets.push(e[1]); }); }dispose () { EventHandler.off(this._scrollElement, EVENT_KEY$2), super.dispose(); }_getConfig (e) { return (e = { ...Default$1, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' && e ? e : {} }).target = getElement(e.target) || document.documentElement, typeCheckConfig(NAME$2, e, DefaultType$1), e; }_getScrollTop () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }_getScrollHeight () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }_getOffsetHeight () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }_process () { const e = this._getScrollTop() + this._config.offset; const t = this._getScrollHeight(); const i = this._config.offset + t - this._getOffsetHeight(); if (this._scrollHeight !== t && this.refresh(), e >= i) { const e = this._targets[this._targets.length - 1]; this._activeTarget !== e && this._activate(e); } else { if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let t = this._offsets.length; t--;) this._activeTarget !== this._targets[t] && e >= this._offsets[t] && (void 0 === this._offsets[t + 1] || e < this._offsets[t + 1]) && this._activate(this._targets[t]); } }_activate (e) { this._activeTarget = e, this._clear(); const t = SELECTOR_LINK_ITEMS.split(',').map(t => `${t}[data-bs-target="${e}"],${t}[href="${e}"]`); const i = SelectorEngine.findOne(t.join(','), this._config.target); i.classList.add('active'), i.classList.contains('dropdown-item') ? SelectorEngine.findOne('.dropdown-toggle', i.closest('.dropdown')).classList.add('active') : SelectorEngine.parents(i, '.nav, .list-group').forEach(e => { SelectorEngine.prev(e, '.nav-link, .list-group-item').forEach(e => e.classList.add('active')), SelectorEngine.prev(e, '.nav-item').forEach(e => { SelectorEngine.children(e, '.nav-link').forEach(e => e.classList.add('active')); }); }), EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, { relatedTarget: e }); }_clear () { SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter(e => e.classList.contains('active')).forEach(e => e.classList.remove('active')); } static jQueryInterface (e) { return this.each(function () { const t = ScrollSpy.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } }); }}EventHandler.on(window, EVENT_LOAD_DATA_API, () => { SelectorEngine.find(SELECTOR_DATA_SPY).forEach(e => new ScrollSpy(e)); }), defineJQueryPlugin(ScrollSpy); const NAME$1 = 'tab'; const DATA_KEY$1 = 'bs.tab'; const EVENT_KEY$1 = '.bs.tab'; const DATA_API_KEY = '.data-api'; const EVENT_HIDE$1 = 'hide.bs.tab'; const EVENT_HIDDEN$1 = 'hidden.bs.tab'; const EVENT_SHOW$1 = 'show.bs.tab'; const EVENT_SHOWN$1 = 'shown.bs.tab'; const EVENT_CLICK_DATA_API = 'click.bs.tab.data-api'; const CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu'; const CLASS_NAME_ACTIVE = 'active'; const CLASS_NAME_FADE$1 = 'fade'; const CLASS_NAME_SHOW$1 = 'show'; const SELECTOR_DROPDOWN = '.dropdown'; const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group'; const SELECTOR_ACTIVE = '.active'; const SELECTOR_ACTIVE_UL = ':scope > li > .active'; const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle'; const SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active'; class Tab extends BaseComponent {static get NAME () { return 'tab'; }show () { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains('active')) return; let e; const t = getElementFromSelector(this._element); const i = this._element.closest('.nav, .list-group'); if (i) { const t = i.nodeName === 'UL' || i.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : '.active'; e = SelectorEngine.find(t, i), e = e[e.length - 1]; } const n = e ? EventHandler.trigger(e, EVENT_HIDE$1, { relatedTarget: this._element }) : null; if (EventHandler.trigger(this._element, EVENT_SHOW$1, { relatedTarget: e }).defaultPrevented || n !== null && n.defaultPrevented) return; this._activate(this._element, i); const s = () => { EventHandler.trigger(e, EVENT_HIDDEN$1, { relatedTarget: this._element }), EventHandler.trigger(this._element, EVENT_SHOWN$1, { relatedTarget: e }); }; t ? this._activate(t, t.parentNode, s) : s(); }_activate (e, t, i) { const n = (!t || t.nodeName !== 'UL' && t.nodeName !== 'OL' ? SelectorEngine.children(t, '.active') : SelectorEngine.find(SELECTOR_ACTIVE_UL, t))[0]; const s = i && n && n.classList.contains('fade'); const o = () => this._transitionComplete(e, n, i); n && s ? (n.classList.remove('show'), this._queueCallback(o, e, !0)) : o(); }_transitionComplete (e, t, i) { if (t) { t.classList.remove('active'); const e = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, t.parentNode); e && e.classList.remove('active'), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !1); }e.classList.add('active'), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !0), reflow(e), e.classList.contains('fade') && e.classList.add('show'); let n = e.parentNode; if (n && n.nodeName === 'LI' && (n = n.parentNode), n && n.classList.contains('dropdown-menu')) { const t = e.closest('.dropdown'); t && SelectorEngine.find('.dropdown-toggle', t).forEach(e => e.classList.add('active')), e.setAttribute('aria-expanded', !0); }i && i(); } static jQueryInterface (e) { return this.each(function () { const t = Tab.getOrCreateInstance(this); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](); } }); }}EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (e) { ['A', 'AREA'].includes(this.tagName) && e.preventDefault(), isDisabled(this) || Tab.getOrCreateInstance(this).show(); }), defineJQueryPlugin(Tab); const NAME = 'toast'; const DATA_KEY = 'bs.toast'; const EVENT_KEY = '.bs.toast'; const EVENT_MOUSEOVER = 'mouseover.bs.toast'; const EVENT_MOUSEOUT = 'mouseout.bs.toast'; const EVENT_FOCUSIN = 'focusin.bs.toast'; const EVENT_FOCUSOUT = 'focusout.bs.toast'; const EVENT_HIDE = 'hide.bs.toast'; const EVENT_HIDDEN = 'hidden.bs.toast'; const EVENT_SHOW = 'show.bs.toast'; const EVENT_SHOWN = 'shown.bs.toast'; const CLASS_NAME_FADE = 'fade'; const CLASS_NAME_HIDE = 'hide'; const CLASS_NAME_SHOW = 'show'; const CLASS_NAME_SHOWING = 'showing'; const DefaultType = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const Default = { animation: !0, autohide: !0, delay: 5e3 }; class Toast extends BaseComponent {constructor (e, t) { super(e), this._config = this._getConfig(t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(); } static get DefaultType () { return DefaultType; } static get Default () { return Default; } static get NAME () { return NAME; }show () { EventHandler.trigger(this._element, EVENT_SHOW).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add('fade'), this._element.classList.remove('hide'), reflow(this._element), this._element.classList.add('show'), this._element.classList.add('showing'), this._queueCallback(() => { this._element.classList.remove('showing'), EventHandler.trigger(this._element, EVENT_SHOWN), this._maybeScheduleHide(); }, this._element, this._config.animation)); }hide () { this._element.classList.contains('show') && (EventHandler.trigger(this._element, EVENT_HIDE).defaultPrevented || (this._element.classList.add('showing'), this._queueCallback(() => { this._element.classList.add('hide'), this._element.classList.remove('showing'), this._element.classList.remove('show'), EventHandler.trigger(this._element, EVENT_HIDDEN); }, this._element, this._config.animation))); }dispose () { this._clearTimeout(), this._element.classList.contains('show') && this._element.classList.remove('show'), super.dispose(); }_getConfig (e) { return e = { ...Default, ...Manipulator.getDataAttributes(this._element), ...typeof e === 'object' && e ? e : {} }, typeCheckConfig(NAME, e, this.constructor.DefaultType), e; }_maybeScheduleHide () { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide(); }, this._config.delay))); }_onInteraction (e, t) { switch (e.type) { case 'mouseover':case 'mouseout':this._hasMouseInteraction = t; break; case 'focusin':case 'focusout':this._hasKeyboardInteraction = t; } if (t) return void this._clearTimeout(); const i = e.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide(); }_setListeners () { EventHandler.on(this._element, EVENT_MOUSEOVER, e => this._onInteraction(e, !0)), EventHandler.on(this._element, EVENT_MOUSEOUT, e => this._onInteraction(e, !1)), EventHandler.on(this._element, EVENT_FOCUSIN, e => this._onInteraction(e, !0)), EventHandler.on(this._element, EVENT_FOCUSOUT, e => this._onInteraction(e, !1)); }_clearTimeout () { clearTimeout(this._timeout), this._timeout = null; } static jQueryInterface (e) { return this.each(function () { const t = Toast.getOrCreateInstance(this, e); if (typeof e === 'string') { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](this); } }); }}enableDismissTrigger(Toast), defineJQueryPlugin(Toast); export { Alert, Button, Carousel, Collapse, Dropdown, Modal, Offcanvas, Popover, ScrollSpy, Tab, Toast, Tooltip };
// # sourceMappingURL=bootstrap.esm.min.js.map
